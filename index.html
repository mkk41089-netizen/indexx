import React, { useState, useEffect, useCallback } from 'react';
import { Sparkles, RefreshCw, Trophy, Timer, Play, RotateCcw } from 'lucide-react';

// å¯¶çŸ³ç¨®é¡ (ä½¿ç”¨ Emoji)
const GEM_TYPES = ['ğŸ’', 'Ruby', 'Emerald', 'Gold', 'Amethyst', 'Sapphire'];
// å°æ‡‰çš„é¡¯ç¤ºåœ–ç¤º
const GEM_ICONS = {
  'ğŸ’': 'ğŸ’',      // é‘½çŸ³ (è—)
  'Ruby': 'â¤ï¸',    // ç´…å¿ƒ (ç´…)
  'Emerald': 'ğŸ€', // å››è‘‰è‰ (ç¶ )
  'Gold': 'â­',    // æ˜Ÿæ˜Ÿ (é»ƒ)
  'Amethyst': 'ğŸŸ£',// åœ“å½¢ (ç´«)
  'Sapphire': 'ğŸ”·' // æ–¹å½¢ (æ·±è—)
};

// ç‰ˆé¢å¤§å°
const BOARD_SIZE = 8;

const App = () => {
  const [board, setBoard] = useState([]);
  const [selectedGem, setSelectedGem] = useState(null);
  const [score, setScore] = useState(0);
  const [timeLeft, setTimeLeft] = useState(60);
  const [gameState, setGameState] = useState('idle'); // idle, playing, gameover
  const [isProcessing, setIsProcessing] = useState(false);
  const [combo, setCombo] = useState(0);

  // åˆå§‹åŒ–éŠæˆ²ç›¤é¢
  const createBoard = useCallback(() => {
    const newBoard = [];
    for (let i = 0; i < BOARD_SIZE; i++) {
      const row = [];
      for (let j = 0; j < BOARD_SIZE; j++) {
        row.push(GEM_TYPES[Math.floor(Math.random() * GEM_TYPES.length)]);
      }
      newBoard.push(row);
    }
    // ç°¡å–®æª¢æŸ¥åˆå§‹ä¸æ‡‰è©²æœ‰å¤ªå¤šé€£ç·šï¼Œé€™è£¡ç‚ºäº†æµæš¢åº¦å…ˆå…è¨±ï¼Œåæ­£æœƒè¢« useEffect æ¶ˆé™¤
    return newBoard;
  }, []);

  const startGame = () => {
    setBoard(createBoard());
    setScore(0);
    setTimeLeft(60);
    setGameState('playing');
    setCombo(0);
    setIsProcessing(false);
    setSelectedGem(null);
  };

  // è¨ˆæ™‚å™¨
  useEffect(() => {
    let timer;
    if (gameState === 'playing' && timeLeft > 0) {
      timer = setInterval(() => {
        setTimeLeft((prev) => prev - 1);
      }, 1000);
    } else if (timeLeft === 0 && gameState === 'playing') {
      setGameState('gameover');
    }
    return () => clearInterval(timer);
  }, [gameState, timeLeft]);

  // æª¢æŸ¥æ˜¯å¦æœ‰åŒ¹é… (æ©«å‘æˆ–ç¸±å‘ 3 å€‹ä»¥ä¸Š)
  const checkForMatches = useCallback((currentBoard) => {
    const matches = new Set();

    // æ©«å‘æª¢æŸ¥
    for (let r = 0; r < BOARD_SIZE; r++) {
      for (let c = 0; c < BOARD_SIZE - 2; c++) {
        const gem1 = currentBoard[r][c];
        const gem2 = currentBoard[r][c + 1];
        const gem3 = currentBoard[r][c + 2];
        if (gem1 && gem1 === gem2 && gem2 === gem3) {
          matches.add(`${r},${c}`);
          matches.add(`${r},${c + 1}`);
          matches.add(`${r},${c + 2}`);
        }
      }
    }

    // ç¸±å‘æª¢æŸ¥
    for (let c = 0; c < BOARD_SIZE; c++) {
      for (let r = 0; r < BOARD_SIZE - 2; r++) {
        const gem1 = currentBoard[r][c];
        const gem2 = currentBoard[r + 1][c];
        const gem3 = currentBoard[r + 2][c];
        if (gem1 && gem1 === gem2 && gem2 === gem3) {
          matches.add(`${r},${c}`);
          matches.add(`${r + 1},${c}`);
          matches.add(`${r + 2},${c}`);
        }
      }
    }

    return Array.from(matches).map(str => {
      const [r, c] = str.split(',').map(Number);
      return { r, c };
    });
  }, []);

  // éŠæˆ²ä¸»å¾ªç’°é‚è¼¯ (æ¶ˆé™¤ -> ä¸‹è½ -> å¡«å……)
  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = async () => {
      const matches = checkForMatches(board);

      if (matches.length > 0) {
        setIsProcessing(true);
        
        // 1. ç­‰å¾…ä¸€ä¸‹è®“ç©å®¶çœ‹åˆ°é€£ç·š (å¯é¸ï¼Œé€™è£¡ç‚ºäº†ç¯€å¥å¿«ç›´æ¥æ¶ˆé™¤)
        await new Promise(resolve => setTimeout(resolve, 300));

        // 2. æ¶ˆé™¤å¯¶çŸ³ä¸¦è¨ˆç®—åˆ†æ•¸
        const newBoard = board.map(row => [...row]);
        matches.forEach(({ r, c }) => {
          newBoard[r][c] = null; // æ¨™è¨˜ç‚ºç©º
        });

        setScore(prev => prev + matches.length * 10 * (combo + 1));
        setCombo(prev => prev + 1);
        setBoard(newBoard);

        // 3. ä¸‹è½é‚è¼¯
        setTimeout(() => {
          const boardAfterFall = handleGravity(newBoard);
          setBoard(boardAfterFall);
          
          // 4. å¡«å……æ–°å¯¶çŸ³
          setTimeout(() => {
             const boardRefilled = refillBoard(boardAfterFall);
             setBoard(boardRefilled);
             // å¾ªç’°æœƒå†æ¬¡è§¸ç™¼ useEffectï¼Œç›´åˆ°æ²’æœ‰åŒ¹é…
          }, 300);
        }, 300);

      } else {
        setIsProcessing(false);
        setCombo(0);
      }
    };

    gameLoop();
  }, [board, gameState, checkForMatches, combo]);

  // è™•ç†é‡åŠ› (å¯¶çŸ³ä¸‹è½)
  const handleGravity = (currentBoard) => {
    const newBoard = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));

    for (let c = 0; c < BOARD_SIZE; c++) {
      let writeRow = BOARD_SIZE - 1;
      for (let r = BOARD_SIZE - 1; r >= 0; r--) {
        if (currentBoard[r][c] !== null) {
          newBoard[writeRow][c] = currentBoard[r][c];
          writeRow--;
        }
      }
    }
    return newBoard;
  };

  // å¡«å……ç©ºç¼º
  const refillBoard = (currentBoard) => {
    const newBoard = currentBoard.map(row => [...row]);
    for (let r = 0; r < BOARD_SIZE; r++) {
      for (let c = 0; c < BOARD_SIZE; c++) {
        if (newBoard[r][c] === null) {
          newBoard[r][c] = GEM_TYPES[Math.floor(Math.random() * GEM_TYPES.length)];
        }
      }
    }
    return newBoard;
  };

  // è™•ç†é»æ“Š
  const handleGemClick = (r, c) => {
    if (gameState !== 'playing' || isProcessing) return;

    // å¦‚æœæ²’æœ‰é¸ä¸­ï¼Œå‰‡é¸ä¸­
    if (!selectedGem) {
      setSelectedGem({ r, c });
      return;
    }

    // å¦‚æœé»æ“ŠåŒä¸€å€‹ï¼Œå–æ¶ˆé¸ä¸­
    if (selectedGem.r === r && selectedGem.c === c) {
      setSelectedGem(null);
      return;
    }

    // æª¢æŸ¥æ˜¯å¦ç›¸é„°
    const isAdjacent = 
      (Math.abs(selectedGem.r - r) === 1 && selectedGem.c === c) ||
      (Math.abs(selectedGem.c - c) === 1 && selectedGem.r === r);

    if (isAdjacent) {
      attemptSwap(selectedGem, { r, c });
      setSelectedGem(null);
    } else {
      // å¦‚æœä¸ç›¸é„°ï¼Œç›´æ¥åˆ‡æ›é¸ä¸­ç›®æ¨™
      setSelectedGem({ r, c });
    }
  };

  // å˜—è©¦äº¤æ›
  const attemptSwap = async (pos1, pos2) => {
    setIsProcessing(true);
    
    // å»ºç«‹è‡¨æ™‚äº¤æ›å¾Œçš„ç‰ˆé¢
    const tempBoard = board.map(row => [...row]);
    const gem1 = tempBoard[pos1.r][pos1.c];
    const gem2 = tempBoard[pos2.r][pos2.c];
    tempBoard[pos1.r][pos1.c] = gem2;
    tempBoard[pos2.r][pos2.c] = gem1;

    setBoard(tempBoard);

    // ç­‰å¾…å‹•ç•«æ™‚é–“
    await new Promise(resolve => setTimeout(resolve, 300));

    // æª¢æŸ¥äº¤æ›å¾Œæ˜¯å¦æœ‰æ•ˆ
    const matches = checkForMatches(tempBoard);

    if (matches.length === 0) {
      // ç„¡æ•ˆäº¤æ›ï¼Œæ›å›ä¾†
      const revertBoard = tempBoard.map(row => [...row]);
      revertBoard[pos1.r][pos1.c] = gem1;
      revertBoard[pos2.r][pos2.c] = gem2;
      setBoard(revertBoard);
      setIsProcessing(false);
    } else {
      // æœ‰æ•ˆäº¤æ›ï¼ŒuseEffect æœƒæ¥æ‰‹è™•ç†æ¶ˆé™¤é‚è¼¯
      // é€™è£¡ä¸éœ€è¦åšä»€éº¼ï¼Œå› ç‚º state å·²ç¶“æ›´æ–°ç‚º tempBoard
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-800 flex flex-col items-center justify-center p-4 font-sans text-white select-none">
      
      {/* æ¨™é¡Œèˆ‡æ•¸æ“šæ¬„ */}
      <div className="w-full max-w-md mb-6 flex justify-between items-center bg-white/10 backdrop-blur-md p-4 rounded-2xl shadow-xl border border-white/20">
        <div className="flex flex-col items-center">
          <div className="flex items-center text-yellow-400 mb-1">
            <Trophy size={20} className="mr-1" />
            <span className="text-xs uppercase tracking-wider font-bold">åˆ†æ•¸</span>
          </div>
          <span className="text-2xl font-black font-mono">{score}</span>
        </div>

        <div className="flex flex-col items-center">
          <div className="flex items-center text-pink-400 mb-1">
            <Timer size={20} className="mr-1" />
            <span className="text-xs uppercase tracking-wider font-bold">æ™‚é–“</span>
          </div>
          <span className={`text-2xl font-black font-mono ${timeLeft <= 10 ? 'text-red-500 animate-pulse' : ''}`}>
            {timeLeft}
          </span>
        </div>
      </div>

      {/* éŠæˆ²å€åŸŸ */}
      <div className="relative">
        <div 
          className="grid grid-cols-8 gap-1 bg-black/40 p-2 rounded-xl shadow-2xl backdrop-blur-sm border-2 border-white/10"
          style={{ width: 'min(90vw, 400px)', height: 'min(90vw, 400px)' }}
        >
          {gameState === 'idle' ? (
            <div className="absolute inset-0 z-10 flex flex-col items-center justify-center bg-black/60 rounded-xl backdrop-blur-sm">
              <Sparkles size={64} className="text-yellow-400 mb-4 animate-bounce" />
              <h1 className="text-4xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-pink-500">
                å¯¶çŸ³æ¶ˆæ¶ˆæ¨‚
              </h1>
              <p className="text-gray-300 mb-8">é»æ“Šç›¸é„°å¯¶çŸ³é€²è¡Œäº¤æ›æ¶ˆé™¤ï¼</p>
              <button 
                onClick={startGame}
                className="group relative px-8 py-3 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full font-bold text-lg shadow-lg hover:shadow-blue-500/50 transition-all transform hover:-translate-y-1 active:scale-95 flex items-center"
              >
                <Play size={24} className="mr-2 fill-current" />
                é–‹å§‹éŠæˆ²
              </button>
            </div>
          ) : null}

          {gameState === 'gameover' ? (
            <div className="absolute inset-0 z-10 flex flex-col items-center justify-center bg-black/80 rounded-xl backdrop-blur-sm animate-fade-in">
              <h2 className="text-5xl font-bold text-white mb-2 drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">
                æ™‚é–“åˆ°!
              </h2>
              <div className="text-2xl text-yellow-400 mb-6 font-mono">
                æœ€çµ‚å¾—åˆ†: {score}
              </div>
              <button 
                onClick={startGame}
                className="px-8 py-3 bg-gradient-to-r from-green-500 to-emerald-600 rounded-full font-bold text-lg shadow-lg hover:shadow-green-500/50 transition-all transform hover:-translate-y-1 active:scale-95 flex items-center"
              >
                <RotateCcw size={24} className="mr-2" />
                å†ç©ä¸€æ¬¡
              </button>
            </div>
          ) : null}

          {/* ç¶²æ ¼æ¸²æŸ“ */}
          {board.length > 0 && board.map((row, r) => (
            row.map((gem, c) => (
              <div
                key={`${r}-${c}`}
                onClick={() => handleGemClick(r, c)}
                className={`
                  relative flex items-center justify-center
                  rounded-lg cursor-pointer transition-all duration-300
                  ${selectedGem?.r === r && selectedGem?.c === c 
                    ? 'bg-white/30 scale-110 z-10 shadow-[0_0_15px_rgba(255,255,255,0.6)] ring-2 ring-white' 
                    : 'hover:bg-white/10 active:scale-95'}
                  ${!gem ? 'invisible' : ''}
                `}
              >
                <span className="text-2xl sm:text-3xl filter drop-shadow-lg transform transition-transform duration-300 hover:rotate-12">
                  {gem ? GEM_ICONS[gem] : ''}
                </span>
              </div>
            ))
          ))}
        </div>
      </div>

      {/* æ§åˆ¶èˆ‡æç¤º */}
      <div className="mt-8 flex gap-4">
        <button 
          onClick={startGame}
          className="p-3 rounded-full bg-white/10 hover:bg-white/20 backdrop-blur-md transition-colors border border-white/10"
          title="é‡æ–°é–‹å§‹"
        >
          <RefreshCw size={24} />
        </button>
      </div>

      <div className="mt-4 text-white/40 text-sm text-center">
        æ‰‹æ©Ÿä¸Šä¹Ÿèƒ½é †æš¢éŠç© â€¢ è‡ªå‹•å¡«å…… â€¢ é€£æ“ŠåŠ åˆ†
      </div>

      <style jsx global>{`
        @keyframes fade-in {
          from { opacity: 0; transform: scale(0.9); }
          to { opacity: 1; transform: scale(1); }
        }
        .animate-fade-in {
          animation: fade-in 0.3s ease-out forwards;
        }
      `}</style>
    </div>
  );
};

export default App;
